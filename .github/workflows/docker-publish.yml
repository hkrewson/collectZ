name: Build and Publish Images

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.vars.outputs.version }}
      major_minor: ${{ steps.vars.outputs.major_minor }}
      build_date: ${{ steps.vars.outputs.build_date }}
      git_sha_short: ${{ steps.vars.outputs.git_sha_short }}
      owner_lc: ${{ steps.owner.outputs.owner_lc }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Read version
        id: vars
        run: |
          META_VERSION=$(node -p "require('./app-meta.json').version")
          BACKEND_VERSION=$(node -p "require('./backend/package.json').version")
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          if [ "$META_VERSION" != "$BACKEND_VERSION" ] || [ "$META_VERSION" != "$FRONTEND_VERSION" ]; then
            echo "Version mismatch: app-meta=$META_VERSION backend=$BACKEND_VERSION frontend=$FRONTEND_VERSION"
            exit 1
          fi
          MAJOR_MINOR=$(echo "$META_VERSION" | awk -F. '{print $1 "." $2}')
          BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          GIT_SHA_SHORT=$(echo "${GITHUB_SHA}" | cut -c1-7)
          echo "version=$META_VERSION" >> "$GITHUB_OUTPUT"
          echo "major_minor=$MAJOR_MINOR" >> "$GITHUB_OUTPUT"
          echo "build_date=$BUILD_DATE" >> "$GITHUB_OUTPUT"
          echo "git_sha_short=$GIT_SHA_SHORT" >> "$GITHUB_OUTPUT"

      - name: Verify release notes exist and include required sections
        run: |
          VERSION="${{ steps.vars.outputs.version }}"
          NOTE_FILE="docs/releases/v${VERSION}.md"
          if [ ! -f "$NOTE_FILE" ]; then
            echo "Missing release notes file: $NOTE_FILE"
            exit 1
          fi
          required_sections=(
            "## Version and date"
            "## Milestone target and status"
            "## Summary"
            "## What changed"
            "## Breaking changes"
            "## Environment/config changes"
            "## Migration and data impact"
            "## Deployment and verification"
            "## Rollback guidance"
            "## Known issues and follow-up"
          )
          for section in "${required_sections[@]}"; do
            if ! grep -Fq "$section" "$NOTE_FILE"; then
              echo "Release notes missing section '$section' in $NOTE_FILE"
              exit 1
            fi
          done
          echo "Release notes check passed for $NOTE_FILE"

      - name: Enforce lockfile policy
        run: |
          test -f backend/package-lock.json || { echo "Missing required lockfile: backend/package-lock.json"; exit 1; }
          test -f frontend/package-lock.json || { echo "Missing required lockfile: frontend/package-lock.json"; exit 1; }
          echo "Lockfile policy check passed."

      - name: Enforce runtime dependency policy
        run: |
          if grep -Eq '^[[:space:]]+container_name:' docker-compose.yml docker-compose.registry.yml; then
            echo "container_name is forbidden in compose files (breaks portable topology and parallel stacks)."
            exit 1
          fi
          if grep -Eq '^[[:space:]]+redis:' docker-compose.yml docker-compose.registry.yml; then
            echo "Redis service found in compose files, but runtime policy is Postgres-only."
            exit 1
          fi
          if grep -Eq 'REDIS_URL|REDIS_PASSWORD' docker-compose.yml docker-compose.registry.yml env.example; then
            echo "Redis runtime env vars found in compose/env files."
            exit 1
          fi
          if node -e "const pkg=require('./backend/package.json'); const deps={...(pkg.dependencies||{}),...(pkg.devDependencies||{})}; if(deps.redis||deps['connect-redis']) process.exit(1);"; then
            echo "Runtime dependency policy check passed."
          else
            echo "Forbidden backend deps found (redis/connect-redis)."
            exit 1
          fi

      - name: Enforce App.js modularity budget
        run: |
          APP_FILE="frontend/src/App.js"
          HARD_BUDGET=550
          LINE_COUNT=$(wc -l < "$APP_FILE" | tr -d ' ')
          echo "App.js line count: $LINE_COUNT (hard budget: $HARD_BUDGET)"
          if [ "$LINE_COUNT" -le "$HARD_BUDGET" ]; then
            echo "App.js budget check passed."
            exit 0
          fi
          EX_FILE=".ci/exceptions/app-shell-budget.json"
          if [ ! -f "$EX_FILE" ]; then
            echo "App.js exceeds hard budget and no exception file exists: $EX_FILE"
            exit 1
          fi
          node <<'NODE'
          const fs = require('fs');
          const path = '.ci/exceptions/app-shell-budget.json';
          const appFile = 'frontend/src/App.js';
          const hardBudget = 550;
          const lineCount = Number(fs.readFileSync(appFile, 'utf8').split('\n').length);
          const raw = fs.readFileSync(path, 'utf8');
          const ex = JSON.parse(raw);
          const required = ['reason', 'approved_by', 'expires_on', 'max_lines', 'target_milestone'];
          for (const key of required) {
            if (!ex[key]) {
              throw new Error(`App.js exception missing required field: ${key}`);
            }
          }
          const expires = new Date(ex.expires_on);
          if (Number.isNaN(expires.getTime())) {
            throw new Error('App.js exception expires_on is not a valid date (YYYY-MM-DD expected).');
          }
          if (expires.getTime() < Date.now()) {
            throw new Error(`App.js exception expired on ${ex.expires_on}.`);
          }
          if (!Number.isInteger(ex.max_lines) || ex.max_lines < hardBudget) {
            throw new Error(`App.js exception max_lines must be an integer >= ${hardBudget}.`);
          }
          if (lineCount > ex.max_lines) {
            throw new Error(`App.js line count ${lineCount} exceeds exception max_lines ${ex.max_lines}.`);
          }
          console.log(`App.js exception accepted through ${ex.expires_on} (target ${ex.target_milestone}).`);
          NODE

      - name: Lowercase owner
        id: owner
        run: |
          echo "owner_lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

  dependency-scan:
    runs-on: ubuntu-latest
    needs: prepare
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install backend deps
        working-directory: backend
        run: npm ci --no-fund

      - name: Install frontend deps
        working-directory: frontend
        run: npm ci --no-fund

      - name: Run backend dependency audit
        working-directory: backend
        run: npm audit --omit=dev --json > ../backend-audit.json || true

      - name: Run frontend dependency audit
        working-directory: frontend
        run: npm audit --omit=dev --json > ../frontend-audit.json || true

      - name: Enforce vulnerability threshold
        run: |
          node <<'NODE'
          const fs = require('fs');

          const threshold = 'critical';
          const levels = ['low', 'moderate', 'high', 'critical'];
          const thresholdIndex = levels.indexOf(threshold);
          const files = ['backend-audit.json', 'frontend-audit.json'];

          let failed = false;
          for (const file of files) {
            const raw = fs.readFileSync(file, 'utf8');
            const parsed = JSON.parse(raw);
            const counts = parsed?.metadata?.vulnerabilities || {};
            const over = levels
              .slice(thresholdIndex)
              .reduce((acc, level) => acc + (Number(counts[level] || 0)), 0);
            console.log(`${file}: low=${counts.low || 0} moderate=${counts.moderate || 0} high=${counts.high || 0} critical=${counts.critical || 0}`);
            if (over > 0) {
              failed = true;
            }
          }
          if (failed) {
            console.error(`Dependency vulnerability gate failed (threshold: ${threshold}+).`);
            process.exit(1);
          }
          NODE

      - name: Enforce high vulnerability triage documentation
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          node <<'NODE'
          const fs = require('fs');
          const version = process.env.VERSION;
          const files = ['backend-audit.json', 'frontend-audit.json'];
          let highCount = 0;
          for (const file of files) {
            const parsed = JSON.parse(fs.readFileSync(file, 'utf8'));
            const counts = parsed?.metadata?.vulnerabilities || {};
            highCount += Number(counts.high || 0);
          }
          if (highCount === 0) {
            console.log('No high vulnerabilities detected; triage note not required.');
            process.exit(0);
          }
          const notePath = `docs/releases/v${version}.md`;
          if (!fs.existsSync(notePath)) {
            throw new Error(`Release note not found for triage check: ${notePath}`);
          }
          const note = fs.readFileSync(notePath, 'utf8');
          const requiredMarkers = [
            '## Security vulnerability triage',
            'High findings:',
            'Owner:',
            'Target remediation milestone:'
          ];
          for (const marker of requiredMarkers) {
            if (!note.includes(marker)) {
              throw new Error(`Release note ${notePath} missing required triage marker: ${marker}`);
            }
          }
          console.log(`High vulnerabilities detected (${highCount}); triage documentation present.`);
          NODE

      - name: Upload dependency audit artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dependency-audit
          path: |
            backend-audit.json
            frontend-audit.json

  secret-scan:
    runs-on: ubuntu-latest
    needs: prepare
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run secret scan (gitleaks)
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  migration-check:
    runs-on: ubuntu-latest
    needs: prepare
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: collectz_ci
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres -d collectz_ci"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install backend deps
        working-directory: backend
        run: npm ci --no-audit --no-fund

      - name: Run backend unit tests
        working-directory: backend
        run: npm run test:unit

      - name: Wait for Postgres
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          DATABASE_SSL: "false"
        run: |
          node -e "const {Client}=require('pg'); (async()=>{for(let i=0;i<30;i++){const c=new Client({connectionString:process.env.DATABASE_URL, ssl:false}); try{await c.connect(); await c.end(); console.log('Postgres ready'); process.exit(0);}catch(e){try{await c.end();}catch{} await new Promise(r=>setTimeout(r,2000));}} console.error('Postgres service did not become ready in time'); process.exit(1);})();"

      - name: Run migrations
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          DATABASE_SSL: "false"
        run: |
          node -e "const {runMigrations}=require('./db/migrations'); const pool=require('./db/pool'); (async()=>{await runMigrations(); await pool.end();})().catch(async (e)=>{console.error(e); try{await pool.end();}catch{} process.exit(1);});"

      - name: Verify critical schema columns
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          DATABASE_SSL: "false"
        run: |
          node <<'NODE'
          const pool = require('./db/pool');

          (async () => {
            const checks = [
              ['app_integrations', 'plex_api_url'],
              ['app_integrations', 'plex_library_sections'],
              ['invites', 'revoked'],
              ['invites', 'used_by'],
              ['invites', 'token_hash'],
              ['password_reset_tokens', 'token_hash'],
              ['users', 'active_space_id'],
              ['users', 'active_library_id'],
              ['library_memberships', 'library_id']
            ];
            for (const [table, column] of checks) {
              const r = await pool.query(
                'SELECT 1 FROM information_schema.columns WHERE table_name = $1 AND column_name = $2',
                [table, column]
              );
              if (r.rows.length === 0) {
                throw new Error(`Missing ${table}.${column}`);
              }
            }
            await pool.end();
          })().catch(async (e) => {
            console.error(e);
            try {
              await pool.end();
            } catch {}
            process.exit(1);
          });
          NODE

      - name: Verify init.sql parity with migrations
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          INIT_PARITY_ADMIN_URL: postgresql://postgres:postgres@localhost:5432/postgres
          DATABASE_SSL: "false"
        run: |
          INIT_PARITY_OUTPUT="artifacts/init-parity-evidence.json" npm run test:init-parity

      - name: Upload init parity evidence
        uses: actions/upload-artifact@v4
        with:
          name: init-parity-evidence
          path: backend/artifacts/init-parity-evidence.json

      - name: Run migration restore rehearsal
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          MIGRATION_REHEARSAL_ADMIN_URL: postgresql://postgres:postgres@localhost:5432/postgres
          DATABASE_SSL: "false"
        run: |
          BASELINE=$(node -e "const {MIGRATIONS}=require('./db/migrations'); const latest=Math.max(...MIGRATIONS.map(m=>m.version)); process.stdout.write(String(latest-1));")
          echo "Using baseline migration version: ${BASELINE}"
          MIGRATION_BASELINE_VERSION="${BASELINE}" \
          MIGRATION_REHEARSAL_OUTPUT="artifacts/migration-rehearsal-evidence.json" \
          npm run test:migration-rehearsal

      - name: Upload migration rehearsal evidence
        uses: actions/upload-artifact@v4
        with:
          name: migration-rehearsal-evidence
          path: backend/artifacts/migration-rehearsal-evidence.json

  compose-smoke:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build and start compose stack
        env:
          DB_PASSWORD: collectz_ci_db_password
          SESSION_SECRET: collectz_ci_session_secret_32_chars_minimum_ok
          INTEGRATION_ENCRYPTION_KEY: collectz_ci_integration_encryption_key_32_chars_min_ok
          APP_VERSION: ${{ needs.prepare.outputs.version }}
          GIT_SHA: ${{ needs.prepare.outputs.git_sha_short }}
          BUILD_DATE: ${{ needs.prepare.outputs.build_date }}
          NODE_ENV: production
          SESSION_COOKIE_SECURE: true
          TRUST_PROXY: 1
        run: |
          set -euo pipefail
          trap 'docker compose --env-file .env.ci down -v --remove-orphans' EXIT
          cp env.example .env.ci
          {
            echo "DB_PASSWORD=${DB_PASSWORD}"
            echo "SESSION_SECRET=${SESSION_SECRET}"
            echo "INTEGRATION_ENCRYPTION_KEY=${INTEGRATION_ENCRYPTION_KEY}"
            echo "APP_VERSION=${APP_VERSION}"
            echo "GIT_SHA=${GIT_SHA}"
            echo "BUILD_DATE=${BUILD_DATE}"
            echo "NODE_ENV=${NODE_ENV}"
            echo "SESSION_COOKIE_SECURE=${SESSION_COOKIE_SECURE}"
            echo "TRUST_PROXY=${TRUST_PROXY}"
          } >> .env.ci
          docker compose --env-file .env.ci up -d --build
          BACKEND_CID="$(docker compose --env-file .env.ci ps -q backend)"
          FRONTEND_CID="$(docker compose --env-file .env.ci ps -q frontend)"
          test -n "${BACKEND_CID}" || { echo "backend container id not found"; exit 1; }
          test -n "${FRONTEND_CID}" || { echo "frontend container id not found"; exit 1; }
          timeout 120 sh -c 'until [ "$(docker inspect -f "{{.State.Health.Status}}" "'"${BACKEND_CID}"'")" = "healthy" ]; do sleep 3; done'
          timeout 120 sh -c 'until [ "$(docker inspect -f "{{.State.Health.Status}}" "'"${FRONTEND_CID}"'")" = "healthy" ]; do sleep 3; done'

          HEALTH_JSON="$(curl -s http://localhost:3000/api/health)"
          echo "$HEALTH_JSON" | grep -q "\"status\":\"ok\""
          echo "$HEALTH_JSON" | grep -q "\"version\":\"${APP_VERSION}\""
          HEALTH_HEADERS="$(mktemp)"
          curl -s -D "${HEALTH_HEADERS}" -o /dev/null http://localhost:3000/api/health
          grep -qi '^x-content-type-options:' "${HEALTH_HEADERS}" || { echo "Missing x-content-type-options header"; exit 1; }
          grep -qi '^x-frame-options:' "${HEALTH_HEADERS}" || { echo "Missing x-frame-options header"; exit 1; }
          grep -qi '^strict-transport-security:' "${HEALTH_HEADERS}" || { echo "Missing strict-transport-security header"; exit 1; }

          COOKIE_JAR="$(mktemp)"
          CSRF_HEADERS="$(mktemp)"
          CSRF_JSON="$(curl -s -c "${COOKIE_JAR}" -D "${CSRF_HEADERS}" http://localhost:3000/api/auth/csrf-token)"
          CSRF_TOKEN="$(echo "${CSRF_JSON}" | node -e "let d='';process.stdin.on('data',c=>d+=c).on('end',()=>{try{const j=JSON.parse(d);process.stdout.write(j.csrfToken||'');}catch(e){process.exit(1);}})")"
          [ -n "${CSRF_TOKEN}" ] || { echo "Missing CSRF token"; exit 1; }
          grep -qi 'set-cookie: csrf_token=' "${CSRF_HEADERS}" || { echo "Missing csrf cookie"; exit 1; }
          grep -Eqi 'set-cookie: csrf_token=.*;[[:space:]]*Secure;' "${CSRF_HEADERS}" || { echo "CSRF cookie missing Secure attribute"; exit 1; }
          grep -Eqi 'set-cookie: csrf_token=.*;[[:space:]]*SameSite=Strict' "${CSRF_HEADERS}" || { echo "CSRF cookie missing SameSite=Strict"; exit 1; }

          docker compose --env-file .env.ci exec -T backend node -e \
            "const {SESSION_COOKIE_OPTIONS}=require('./middleware/auth'); if(!(SESSION_COOKIE_OPTIONS.httpOnly===true&&SESSION_COOKIE_OPTIONS.secure===true&&String(SESSION_COOKIE_OPTIONS.sameSite).toLowerCase()==='strict')){console.error('Invalid session cookie options', SESSION_COOKIE_OPTIONS);process.exit(1);}"

          STATUS_CODE="$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/auth/me)"
          if [ "$STATUS_CODE" != "401" ]; then
            echo "Expected unauthenticated /api/auth/me to return 401, got $STATUS_CODE"
            exit 1
          fi

          docker compose --env-file .env.ci exec -T backend npm run test:integration-smoke

  rbac-regression:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check, compose-smoke]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build and start compose stack
        env:
          DB_PASSWORD: collectz_ci_db_password
          SESSION_SECRET: collectz_ci_session_secret_32_chars_minimum_ok
          INTEGRATION_ENCRYPTION_KEY: collectz_ci_integration_encryption_key_32_chars_min_ok
          APP_VERSION: ${{ needs.prepare.outputs.version }}
          GIT_SHA: ${{ needs.prepare.outputs.git_sha_short }}
          BUILD_DATE: ${{ needs.prepare.outputs.build_date }}
          NODE_ENV: production
          SESSION_COOKIE_SECURE: true
          TRUST_PROXY: 1
        run: |
          set -euo pipefail
          trap 'docker compose --env-file .env.ci down -v --remove-orphans' EXIT
          cp env.example .env.ci
          {
            echo "DB_PASSWORD=${DB_PASSWORD}"
            echo "SESSION_SECRET=${SESSION_SECRET}"
            echo "INTEGRATION_ENCRYPTION_KEY=${INTEGRATION_ENCRYPTION_KEY}"
            echo "APP_VERSION=${APP_VERSION}"
            echo "GIT_SHA=${GIT_SHA}"
            echo "BUILD_DATE=${BUILD_DATE}"
            echo "NODE_ENV=${NODE_ENV}"
            echo "SESSION_COOKIE_SECURE=${SESSION_COOKIE_SECURE}"
            echo "TRUST_PROXY=${TRUST_PROXY}"
          } >> .env.ci
          docker compose --env-file .env.ci up -d --build
          BACKEND_CID="$(docker compose --env-file .env.ci ps -q backend)"
          FRONTEND_CID="$(docker compose --env-file .env.ci ps -q frontend)"
          test -n "${BACKEND_CID}" || { echo "backend container id not found"; exit 1; }
          test -n "${FRONTEND_CID}" || { echo "frontend container id not found"; exit 1; }
          timeout 120 sh -c 'until [ "$(docker inspect -f "{{.State.Health.Status}}" "'"${BACKEND_CID}"'")" = "healthy" ]; do sleep 3; done'
          timeout 120 sh -c 'until [ "$(docker inspect -f "{{.State.Health.Status}}" "'"${FRONTEND_CID}"'")" = "healthy" ]; do sleep 3; done'
          docker compose --env-file .env.ci exec -T -e BASE_URL=http://frontend:3000 backend node scripts/rbac-regression-check.js

  backend:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check, dependency-scan, secret-scan, compose-smoke, rbac-regression]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata (backend)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-backend
          tags: |
            type=raw,value=${{ needs.prepare.outputs.version }}
            type=raw,value=${{ needs.prepare.outputs.major_minor }}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push backend
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            APP_VERSION=${{ needs.prepare.outputs.version }}
            GIT_SHA=${{ needs.prepare.outputs.git_sha_short }}
            BUILD_DATE=${{ needs.prepare.outputs.build_date }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  frontend:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check, dependency-scan, secret-scan, compose-smoke, rbac-regression]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata (frontend)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-frontend
          tags: |
            type=raw,value=${{ needs.prepare.outputs.version }}
            type=raw,value=${{ needs.prepare.outputs.major_minor }}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push frontend
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            REACT_APP_API_URL=/api
            REACT_APP_VERSION=${{ needs.prepare.outputs.version }}
            REACT_APP_GIT_SHA=${{ needs.prepare.outputs.git_sha_short }}
            REACT_APP_BUILD_DATE=${{ needs.prepare.outputs.build_date }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  image-security-and-sbom:
    runs-on: ubuntu-latest
    needs: [prepare, backend, frontend]
    steps:
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Scan backend image (critical vulnerabilities)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-backend:${{ needs.prepare.outputs.version }}
          format: table
          exit-code: '1'
          ignore-unfixed: true
          severity: CRITICAL
          vuln-type: os,library

      - name: Scan frontend image (critical vulnerabilities)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-frontend:${{ needs.prepare.outputs.version }}
          format: table
          exit-code: '1'
          ignore-unfixed: true
          severity: CRITICAL
          vuln-type: os,library

      - name: Generate backend SBOM (CycloneDX JSON)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-backend:${{ needs.prepare.outputs.version }}
          format: cyclonedx
          output: backend-sbom.cdx.json

      - name: Generate frontend SBOM (CycloneDX JSON)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-frontend:${{ needs.prepare.outputs.version }}
          format: cyclonedx
          output: frontend-sbom.cdx.json

      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-cyclonedx
          path: |
            backend-sbom.cdx.json
            frontend-sbom.cdx.json

  release-preflight:
    runs-on: ubuntu-latest
    needs: [prepare, secret-scan, dependency-scan, migration-check, compose-smoke, rbac-regression, image-security-and-sbom]
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Download dependency audit artifact
        uses: actions/download-artifact@v4
        with:
          name: dependency-audit
          path: artifacts/dependency-audit

      - name: Download init parity evidence artifact
        uses: actions/download-artifact@v4
        with:
          name: init-parity-evidence
          path: artifacts/init-parity-evidence

      - name: Download migration rehearsal evidence artifact
        uses: actions/download-artifact@v4
        with:
          name: migration-rehearsal-evidence
          path: artifacts/migration-rehearsal-evidence

      - name: Download SBOM artifact
        uses: actions/download-artifact@v4
        with:
          name: sbom-cyclonedx
          path: artifacts/sbom-cyclonedx

      - name: Validate preflight evidence and generate report
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          REF: ${{ github.ref }}
          SHA: ${{ github.sha }}
          RUN_ID: ${{ github.run_id }}
          REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          test -f artifacts/dependency-audit/backend-audit.json
          test -f artifacts/dependency-audit/frontend-audit.json
          test -f artifacts/init-parity-evidence/init-parity-evidence.json
          test -f artifacts/migration-rehearsal-evidence/migration-rehearsal-evidence.json
          test -f artifacts/sbom-cyclonedx/backend-sbom.cdx.json
          test -f artifacts/sbom-cyclonedx/frontend-sbom.cdx.json

          REPORT="preflight-go-no-go.md"
          {
            echo "# Pre-2.0 Go/No-Go Preflight"
            echo
            echo "- Version: \`${VERSION}\`"
            echo "- Ref: \`${REF}\`"
            echo "- Commit: \`${SHA}\`"
            echo "- Run: https://github.com/${REPOSITORY}/actions/runs/${RUN_ID}"
            echo
            echo "## Gate Results"
            echo
            echo "- Secret scan: PASS"
            echo "- Dependency scan: PASS"
            echo "- Migration check: PASS"
            echo "- Compose smoke: PASS"
            echo "- RBAC regression: PASS"
            echo "- Image security and SBOM: PASS"
            echo
            echo "## Evidence Artifacts"
            echo
            echo "- \`dependency-audit/backend-audit.json\`"
            echo "- \`dependency-audit/frontend-audit.json\`"
            echo "- \`init-parity-evidence/init-parity-evidence.json\`"
            echo "- \`migration-rehearsal-evidence/migration-rehearsal-evidence.json\`"
            echo "- \`sbom-cyclonedx/backend-sbom.cdx.json\`"
            echo "- \`sbom-cyclonedx/frontend-sbom.cdx.json\`"
            echo
            echo "## Blocking Criteria"
            echo
            echo "Release is NO-GO if any required gate fails or any required artifact is missing."
            echo
            echo "## Exception Process"
            echo
            echo "Follow \`docs/wiki/14-Engineering-Delivery-Policy.md\` exception rules before any override."
          } > "${REPORT}"

      - name: Upload preflight report artifact
        uses: actions/upload-artifact@v4
        with:
          name: preflight-go-no-go
          path: preflight-go-no-go.md

  auto-tag:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check, dependency-scan, secret-scan, compose-smoke, rbac-regression, backend, frontend, image-security-and-sbom]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create release tag if missing
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          SHA: ${{ github.sha }}
        run: |
          TAG="v${VERSION}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag ${TAG} already exists; skipping"
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" "$SHA" -m "Release ${TAG}"
          git push origin "$TAG"
