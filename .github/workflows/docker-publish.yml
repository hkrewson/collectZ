name: Build and Publish Images

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.vars.outputs.version }}
      major_minor: ${{ steps.vars.outputs.major_minor }}
      build_date: ${{ steps.vars.outputs.build_date }}
      git_sha_short: ${{ steps.vars.outputs.git_sha_short }}
      owner_lc: ${{ steps.owner.outputs.owner_lc }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Read version
        id: vars
        run: |
          META_VERSION=$(node -p "require('./app-meta.json').version")
          BACKEND_VERSION=$(node -p "require('./backend/package.json').version")
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          if [ "$META_VERSION" != "$BACKEND_VERSION" ] || [ "$META_VERSION" != "$FRONTEND_VERSION" ]; then
            echo "Version mismatch: app-meta=$META_VERSION backend=$BACKEND_VERSION frontend=$FRONTEND_VERSION"
            exit 1
          fi
          MAJOR_MINOR=$(echo "$META_VERSION" | awk -F. '{print $1 "." $2}')
          BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          GIT_SHA_SHORT=$(echo "${GITHUB_SHA}" | cut -c1-7)
          echo "version=$META_VERSION" >> "$GITHUB_OUTPUT"
          echo "major_minor=$MAJOR_MINOR" >> "$GITHUB_OUTPUT"
          echo "build_date=$BUILD_DATE" >> "$GITHUB_OUTPUT"
          echo "git_sha_short=$GIT_SHA_SHORT" >> "$GITHUB_OUTPUT"

      - name: Verify release notes exist and include required sections
        run: |
          VERSION="${{ steps.vars.outputs.version }}"
          NOTE_FILE="docs/releases/v${VERSION}.md"
          if [ ! -f "$NOTE_FILE" ]; then
            echo "Missing release notes file: $NOTE_FILE"
            exit 1
          fi
          required_sections=(
            "## Version and date"
            "## Milestone target and status"
            "## Summary"
            "## What changed"
            "## Breaking changes"
            "## Environment/config changes"
            "## Migration and data impact"
            "## Deployment and verification"
            "## Rollback guidance"
            "## Known issues and follow-up"
          )
          for section in "${required_sections[@]}"; do
            if ! grep -Fq "$section" "$NOTE_FILE"; then
              echo "Release notes missing section '$section' in $NOTE_FILE"
              exit 1
            fi
          done
          echo "Release notes check passed for $NOTE_FILE"

      - name: Enforce runtime dependency policy
        run: |
          if grep -Eq '^[[:space:]]+redis:' docker-compose.yml docker-compose.registry.yml; then
            echo "Redis service found in compose files, but runtime policy is Postgres-only."
            exit 1
          fi
          if grep -Eq 'REDIS_URL|REDIS_PASSWORD' docker-compose.yml docker-compose.registry.yml env.example; then
            echo "Redis runtime env vars found in compose/env files."
            exit 1
          fi
          if node -e "const pkg=require('./backend/package.json'); const deps={...(pkg.dependencies||{}),...(pkg.devDependencies||{})}; if(deps.redis||deps['connect-redis']) process.exit(1);"; then
            echo "Runtime dependency policy check passed."
          else
            echo "Forbidden backend deps found (redis/connect-redis)."
            exit 1
          fi

      - name: Lowercase owner
        id: owner
        run: |
          echo "owner_lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

  dependency-scan:
    runs-on: ubuntu-latest
    needs: prepare
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install backend deps
        working-directory: backend
        run: npm install --no-fund

      - name: Install frontend deps
        working-directory: frontend
        run: npm install --no-fund

      - name: Run backend dependency audit
        working-directory: backend
        run: npm audit --omit=dev --json > ../backend-audit.json || true

      - name: Run frontend dependency audit
        working-directory: frontend
        run: npm audit --omit=dev --json > ../frontend-audit.json || true

      - name: Enforce vulnerability threshold
        run: |
          node <<'NODE'
          const fs = require('fs');

          const threshold = 'critical';
          const levels = ['low', 'moderate', 'high', 'critical'];
          const thresholdIndex = levels.indexOf(threshold);
          const files = ['backend-audit.json', 'frontend-audit.json'];

          let failed = false;
          for (const file of files) {
            const raw = fs.readFileSync(file, 'utf8');
            const parsed = JSON.parse(raw);
            const counts = parsed?.metadata?.vulnerabilities || {};
            const over = levels
              .slice(thresholdIndex)
              .reduce((acc, level) => acc + (Number(counts[level] || 0)), 0);
            console.log(`${file}: low=${counts.low || 0} moderate=${counts.moderate || 0} high=${counts.high || 0} critical=${counts.critical || 0}`);
            if (over > 0) {
              failed = true;
            }
          }
          if (failed) {
            console.error(`Dependency vulnerability gate failed (threshold: ${threshold}+).`);
            process.exit(1);
          }
          NODE

      - name: Upload dependency audit artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dependency-audit
          path: |
            backend-audit.json
            frontend-audit.json

  secret-scan:
    runs-on: ubuntu-latest
    needs: prepare
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run secret scan (gitleaks)
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  migration-check:
    runs-on: ubuntu-latest
    needs: prepare
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: collectz_ci
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres -d collectz_ci"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install backend deps
        working-directory: backend
        run: npm install --no-audit --no-fund

      - name: Wait for Postgres
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          DATABASE_SSL: "false"
        run: |
          node -e "const {Client}=require('pg'); (async()=>{for(let i=0;i<30;i++){const c=new Client({connectionString:process.env.DATABASE_URL, ssl:false}); try{await c.connect(); await c.end(); console.log('Postgres ready'); process.exit(0);}catch(e){try{await c.end();}catch{} await new Promise(r=>setTimeout(r,2000));}} console.error('Postgres service did not become ready in time'); process.exit(1);})();"

      - name: Run migrations
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          DATABASE_SSL: "false"
        run: |
          node -e "const {runMigrations}=require('./db/migrations'); const pool=require('./db/pool'); (async()=>{await runMigrations(); await pool.end();})().catch(async (e)=>{console.error(e); try{await pool.end();}catch{} process.exit(1);});"

      - name: Verify critical schema columns
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          DATABASE_SSL: "false"
        run: |
          node <<'NODE'
          const pool = require('./db/pool');

          (async () => {
            const checks = [
              ['app_integrations', 'plex_api_url'],
              ['app_integrations', 'plex_library_sections'],
              ['invites', 'revoked'],
              ['invites', 'used_by'],
              ['invites', 'token_hash'],
              ['password_reset_tokens', 'token_hash'],
              ['users', 'active_space_id'],
              ['users', 'active_library_id'],
              ['library_memberships', 'library_id']
            ];
            for (const [table, column] of checks) {
              const r = await pool.query(
                'SELECT 1 FROM information_schema.columns WHERE table_name = $1 AND column_name = $2',
                [table, column]
              );
              if (r.rows.length === 0) {
                throw new Error(`Missing ${table}.${column}`);
              }
            }
            await pool.end();
          })().catch(async (e) => {
            console.error(e);
            try {
              await pool.end();
            } catch {}
            process.exit(1);
          });
          NODE

      - name: Verify init.sql parity with migrations
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          INIT_PARITY_ADMIN_URL: postgresql://postgres:postgres@localhost:5432/postgres
          DATABASE_SSL: "false"
        run: |
          INIT_PARITY_OUTPUT="artifacts/init-parity-evidence.json" npm run test:init-parity

      - name: Upload init parity evidence
        uses: actions/upload-artifact@v4
        with:
          name: init-parity-evidence
          path: backend/artifacts/init-parity-evidence.json

      - name: Run migration restore rehearsal
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          MIGRATION_REHEARSAL_ADMIN_URL: postgresql://postgres:postgres@localhost:5432/postgres
          DATABASE_SSL: "false"
        run: |
          BASELINE=$(node -e "const {MIGRATIONS}=require('./db/migrations'); const latest=Math.max(...MIGRATIONS.map(m=>m.version)); process.stdout.write(String(latest-1));")
          echo "Using baseline migration version: ${BASELINE}"
          MIGRATION_BASELINE_VERSION="${BASELINE}" \
          MIGRATION_REHEARSAL_OUTPUT="artifacts/migration-rehearsal-evidence.json" \
          npm run test:migration-rehearsal

      - name: Upload migration rehearsal evidence
        uses: actions/upload-artifact@v4
        with:
          name: migration-rehearsal-evidence
          path: backend/artifacts/migration-rehearsal-evidence.json

  compose-smoke:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build and start compose stack
        env:
          DB_PASSWORD: collectz_ci_db_password
          SESSION_SECRET: collectz_ci_session_secret
          INTEGRATION_ENCRYPTION_KEY: collectz_ci_encryption_key
          APP_VERSION: ${{ needs.prepare.outputs.version }}
          GIT_SHA: ${{ needs.prepare.outputs.git_sha_short }}
          BUILD_DATE: ${{ needs.prepare.outputs.build_date }}
          NODE_ENV: production
          SESSION_COOKIE_SECURE: false
          TRUST_PROXY: 1
        run: |
          set -euo pipefail
          trap 'docker compose --env-file .env.ci down -v --remove-orphans' EXIT
          cp env.example .env.ci
          {
            echo "DB_PASSWORD=${DB_PASSWORD}"
            echo "SESSION_SECRET=${SESSION_SECRET}"
            echo "INTEGRATION_ENCRYPTION_KEY=${INTEGRATION_ENCRYPTION_KEY}"
            echo "APP_VERSION=${APP_VERSION}"
            echo "GIT_SHA=${GIT_SHA}"
            echo "BUILD_DATE=${BUILD_DATE}"
            echo "NODE_ENV=${NODE_ENV}"
            echo "SESSION_COOKIE_SECURE=${SESSION_COOKIE_SECURE}"
            echo "TRUST_PROXY=${TRUST_PROXY}"
          } >> .env.ci
          docker compose --env-file .env.ci up -d --build

          timeout 120 sh -c 'until [ "$(docker inspect -f "{{.State.Health.Status}}" mediavault-backend)" = "healthy" ]; do sleep 3; done'
          timeout 120 sh -c 'until [ "$(docker inspect -f "{{.State.Health.Status}}" mediavault-frontend)" = "healthy" ]; do sleep 3; done'

          HEALTH_JSON="$(curl -s http://localhost:3000/api/health)"
          echo "$HEALTH_JSON" | grep -q "\"status\":\"ok\""
          echo "$HEALTH_JSON" | grep -q "\"version\":\"${APP_VERSION}\""
          STATUS_CODE="$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/auth/me)"
          if [ "$STATUS_CODE" != "401" ]; then
            echo "Expected unauthenticated /api/auth/me to return 401, got $STATUS_CODE"
            exit 1
          fi

  backend:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check, dependency-scan, secret-scan, compose-smoke]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata (backend)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-backend
          tags: |
            type=raw,value=${{ needs.prepare.outputs.version }}
            type=raw,value=${{ needs.prepare.outputs.major_minor }}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push backend
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            APP_VERSION=${{ needs.prepare.outputs.version }}
            GIT_SHA=${{ needs.prepare.outputs.git_sha_short }}
            BUILD_DATE=${{ needs.prepare.outputs.build_date }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  frontend:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check, dependency-scan, secret-scan, compose-smoke]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata (frontend)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-frontend
          tags: |
            type=raw,value=${{ needs.prepare.outputs.version }}
            type=raw,value=${{ needs.prepare.outputs.major_minor }}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push frontend
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            REACT_APP_API_URL=/api
            REACT_APP_VERSION=${{ needs.prepare.outputs.version }}
            REACT_APP_GIT_SHA=${{ needs.prepare.outputs.git_sha_short }}
            REACT_APP_BUILD_DATE=${{ needs.prepare.outputs.build_date }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  image-security-and-sbom:
    runs-on: ubuntu-latest
    needs: [prepare, backend, frontend]
    steps:
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Scan backend image (critical vulnerabilities)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-backend:${{ needs.prepare.outputs.version }}
          format: table
          exit-code: '1'
          ignore-unfixed: true
          severity: CRITICAL
          vuln-type: os,library

      - name: Scan frontend image (critical vulnerabilities)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-frontend:${{ needs.prepare.outputs.version }}
          format: table
          exit-code: '1'
          ignore-unfixed: true
          severity: CRITICAL
          vuln-type: os,library

      - name: Generate backend SBOM (CycloneDX JSON)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-backend:${{ needs.prepare.outputs.version }}
          format: cyclonedx
          output: backend-sbom.cdx.json

      - name: Generate frontend SBOM (CycloneDX JSON)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-frontend:${{ needs.prepare.outputs.version }}
          format: cyclonedx
          output: frontend-sbom.cdx.json

      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-cyclonedx
          path: |
            backend-sbom.cdx.json
            frontend-sbom.cdx.json

  auto-tag:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check, dependency-scan, secret-scan, compose-smoke, backend, frontend, image-security-and-sbom]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create release tag if missing
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          SHA: ${{ github.sha }}
        run: |
          TAG="v${VERSION}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag ${TAG} already exists; skipping"
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" "$SHA" -m "Release ${TAG}"
          git push origin "$TAG"
