name: Build and Publish Images

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.vars.outputs.version }}
      major_minor: ${{ steps.vars.outputs.major_minor }}
      build_date: ${{ steps.vars.outputs.build_date }}
      git_sha_short: ${{ steps.vars.outputs.git_sha_short }}
      owner_lc: ${{ steps.owner.outputs.owner_lc }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Read version
        id: vars
        run: |
          META_VERSION=$(node -p "require('./app-meta.json').version")
          BACKEND_VERSION=$(node -p "require('./backend/package.json').version")
          FRONTEND_VERSION=$(node -p "require('./frontend/package.json').version")
          if [ "$META_VERSION" != "$BACKEND_VERSION" ] || [ "$META_VERSION" != "$FRONTEND_VERSION" ]; then
            echo "Version mismatch: app-meta=$META_VERSION backend=$BACKEND_VERSION frontend=$FRONTEND_VERSION"
            exit 1
          fi
          MAJOR_MINOR=$(echo "$META_VERSION" | awk -F. '{print $1 "." $2}')
          BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          GIT_SHA_SHORT=$(echo "${GITHUB_SHA}" | cut -c1-7)
          echo "version=$META_VERSION" >> "$GITHUB_OUTPUT"
          echo "major_minor=$MAJOR_MINOR" >> "$GITHUB_OUTPUT"
          echo "build_date=$BUILD_DATE" >> "$GITHUB_OUTPUT"
          echo "git_sha_short=$GIT_SHA_SHORT" >> "$GITHUB_OUTPUT"

      - name: Verify release notes exist and include required sections
        run: |
          VERSION="${{ steps.vars.outputs.version }}"
          NOTE_FILE="docs/releases/v${VERSION}.md"
          if [ ! -f "$NOTE_FILE" ]; then
            echo "Missing release notes file: $NOTE_FILE"
            exit 1
          fi
          required_sections=(
            "## Version and date"
            "## Milestone target and status"
            "## Summary"
            "## What changed"
            "## Breaking changes"
            "## Environment/config changes"
            "## Migration and data impact"
            "## Deployment and verification"
            "## Rollback guidance"
            "## Known issues and follow-up"
          )
          for section in "${required_sections[@]}"; do
            if ! grep -Fq "$section" "$NOTE_FILE"; then
              echo "Release notes missing section '$section' in $NOTE_FILE"
              exit 1
            fi
          done
          echo "Release notes check passed for $NOTE_FILE"

      - name: Lowercase owner
        id: owner
        run: |
          echo "owner_lc=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

  migration-check:
    runs-on: ubuntu-latest
    needs: prepare
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: collectz_ci
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U postgres -d collectz_ci"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install backend deps
        working-directory: backend
        run: npm install --no-audit --no-fund

      - name: Wait for Postgres
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          DATABASE_SSL: "false"
        run: |
          node -e "const {Client}=require('pg'); (async()=>{for(let i=0;i<30;i++){const c=new Client({connectionString:process.env.DATABASE_URL, ssl:false}); try{await c.connect(); await c.end(); console.log('Postgres ready'); process.exit(0);}catch(e){try{await c.end();}catch{} await new Promise(r=>setTimeout(r,2000));}} console.error('Postgres service did not become ready in time'); process.exit(1);})();"

      - name: Run migrations
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          DATABASE_SSL: "false"
        run: |
          node -e "const {runMigrations}=require('./db/migrations'); const pool=require('./db/pool'); (async()=>{await runMigrations(); await pool.end();})().catch(async (e)=>{console.error(e); try{await pool.end();}catch{} process.exit(1);});"

      - name: Verify critical schema columns
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          DATABASE_SSL: "false"
        run: |
          node <<'NODE'
          const pool = require('./db/pool');

          (async () => {
            const checks = [
              ['app_integrations', 'plex_api_url'],
              ['app_integrations', 'plex_library_sections'],
              ['invites', 'revoked'],
              ['invites', 'used_by']
            ];
            for (const [table, column] of checks) {
              const r = await pool.query(
                'SELECT 1 FROM information_schema.columns WHERE table_name = $1 AND column_name = $2',
                [table, column]
              );
              if (r.rows.length === 0) {
                throw new Error(`Missing ${table}.${column}`);
              }
            }
            await pool.end();
          })().catch(async (e) => {
            console.error(e);
            try {
              await pool.end();
            } catch {}
            process.exit(1);
          });
          NODE

      - name: Verify init.sql parity with migrations
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          INIT_PARITY_ADMIN_URL: postgresql://postgres:postgres@localhost:5432/postgres
          DATABASE_SSL: "false"
        run: |
          INIT_PARITY_OUTPUT="artifacts/init-parity-evidence.json" npm run test:init-parity

      - name: Upload init parity evidence
        uses: actions/upload-artifact@v4
        with:
          name: init-parity-evidence
          path: backend/artifacts/init-parity-evidence.json

      - name: Run migration restore rehearsal
        working-directory: backend
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/collectz_ci
          MIGRATION_REHEARSAL_ADMIN_URL: postgresql://postgres:postgres@localhost:5432/postgres
          DATABASE_SSL: "false"
        run: |
          BASELINE=$(node -e "const {MIGRATIONS}=require('./db/migrations'); const latest=Math.max(...MIGRATIONS.map(m=>m.version)); process.stdout.write(String(latest-1));")
          echo "Using baseline migration version: ${BASELINE}"
          MIGRATION_BASELINE_VERSION="${BASELINE}" \
          MIGRATION_REHEARSAL_OUTPUT="artifacts/migration-rehearsal-evidence.json" \
          npm run test:migration-rehearsal

      - name: Upload migration rehearsal evidence
        uses: actions/upload-artifact@v4
        with:
          name: migration-rehearsal-evidence
          path: backend/artifacts/migration-rehearsal-evidence.json

  backend:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata (backend)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-backend
          tags: |
            type=raw,value=${{ needs.prepare.outputs.version }}
            type=raw,value=${{ needs.prepare.outputs.major_minor }}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push backend
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            APP_VERSION=${{ needs.prepare.outputs.version }}
            GIT_SHA=${{ needs.prepare.outputs.git_sha_short }}
            BUILD_DATE=${{ needs.prepare.outputs.build_date }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  frontend:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata (frontend)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ needs.prepare.outputs.owner_lc }}/collectz-frontend
          tags: |
            type=raw,value=${{ needs.prepare.outputs.version }}
            type=raw,value=${{ needs.prepare.outputs.major_minor }}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push frontend
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            REACT_APP_API_URL=/api
            REACT_APP_VERSION=${{ needs.prepare.outputs.version }}
            REACT_APP_GIT_SHA=${{ needs.prepare.outputs.git_sha_short }}
            REACT_APP_BUILD_DATE=${{ needs.prepare.outputs.build_date }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  auto-tag:
    runs-on: ubuntu-latest
    needs: [prepare, migration-check, backend, frontend]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create release tag if missing
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          SHA: ${{ github.sha }}
        run: |
          TAG="v${VERSION}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag ${TAG} already exists; skipping"
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" "$SHA" -m "Release ${TAG}"
          git push origin "$TAG"
